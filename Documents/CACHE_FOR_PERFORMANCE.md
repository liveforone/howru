# 어플리케이션 캐시를 활용해 성능향상하기

## 캐시
* 캐시는 다양한 종류가 있지만, 네트워크 비용을 최소화한 어플리케이션 캐시를 사용하였습니다.
* 외부 캐시(redis)가 아닙니다.

## DB 캐시 의존
* 무의식속에서 DB 캐시를 의존하며 코딩하곤 했었습니다. 
* 무슨 말인가 하면, "이 쿼리는 자주 발생하게돼. 그렇다면 DB에서 캐시가 적절하게 사용되어 조회 성능에 큰 걱정 없겠지?"
* 와 같이 DB 캐시를 의존하며 쿼리를 작성하고, 이를 이용해 api를 만들었습니다.
* DB의 캐시는 mysql 기준 8.0에서 사라졌고, 
* hibernate가 2차캐시 상에서 엔티티를 캐싱할 수 있지만, 이는 어디까지 엔티티만 가능하며, dto는 불가능했습니다. 
* 대부분의 쿼리에서 성능 향상을 위해 dto 프로젝션을 사용하는데 이는 2차캐시에 캐싱이 안됩니다.
* 즉 dto projection 한 쿼리자체가 캐싱되는 그런것이 필요했습니다.

## 어플리케이션 캐시
* 이에 따라 어플리케이션 캐시를 활용하기로 하였고, 다양한 종류의 캐시가 있지만 스프링의 ConcurrentMapCache 를 사용하기로 결정했습니다.
* 이는 실제 상황에 따라 적절하게 변경하며 사용하면 될것 같습니다.

## 캐시의 조건
* 업데이트가 잦지 않고, 자주 조회되는 데이터에 사용해야합니다.
* 그리고 현재 필자가 일반적으로 사용하고 있는 페이징 방식인 no-offset 기반의 페이징에서는 캐시를 사용해선 안됩니다.
* 너무 캐시를 다루기 힘들어지고 상당히 복잡해져서, 어플리케이션의 복잡도를 너무 높히게됩니다.
* 따라서 일반적인 페이징 상황에 적합합니다.
* 캐시를 변경할때 @CachePut 어노테이션은 메서드의 실행 결과를 캐시에 저장하는데, 이때 캐시에 저장되는 값은 메서드가 반환하는 값입니다. 
* 따라서 command와 query를 분리하는 필자의 정책상 업데이트 메서드에 반환값으로 넣기 안좋으니 해당 캐시데이터를 삭제하는 @CacheEvict을 사용하는 것이 좋습니다.
* 즉 캐시는 데이터의 변경이 일어날때 삭제하는 것이 좋습니다. key를 안다면 key에 해당하는 캐시만 삭제하면되겠지요.
* 복합키 데이터는 캐싱을 사용하지 않는것이 좋습니다. 상당히 복잡해집니다.

## 단건 데이터의 캐시
* 단건 데이터의 캐시를 무시해서는 안됩니다.
* hot 한 게시글의 경우 해당 게시글을 call하는 api의 수는 상상을 초월하게 됩니다.
* 이러한 상황가운데에서 캐시는 빛을 발합니다. DB에 접근하지 않고 바로 캐시에서 값을 긁어오기 때문입니다.
* 해당 데이터가 변경이 일어나서 캐시가 삭제되지 않는이상 hot한 단건 데이터에 대한 조회에서 성능을 끌어올리기 좋기 때문에 단건 데이터의 캐싱을 절대로 무시해서는 안됩니다.

## 결론
* 결론은 다음과 같습니다.
* 단건/카운트 데이터를 캐싱하면 좋다. no-offset 페이징의 경우 캐싱을 하지 말아라. 
* 캐시의 복잡성을 줄이기 위해 key는 하나만 갖는것이 좋다. 그리고 그 키는 외부/내부 식별자를 사용하는 것이 좋다. 즉 최대한 단순하게 캐시를 관리해라.
* 변경이 잦지 않고, 조회가 많이 일어나는 게시글이나 광고에 캐시를 사용하면 아주아주 좋다.
* 캐시의 값을 변경하는 @CachePut은 command/query를 분리하는 cqs에 어울리지 않는다. 따라서 데이터의 변경시에는 해당 캐시를 삭제하라.
* 데이터를 삭제하여 캐시 또한 삭제하여야하는 경우, 메서드의 성공/실패 여부를 따지기위해 beforeInvocation 을 false로 두어 메서드가 끝나고 난 후 캐시가 삭제되도록한다. default는 false이다.