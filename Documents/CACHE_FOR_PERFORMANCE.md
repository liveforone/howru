# 캐시를 활용해 성능향상하기

## DB 캐시 의존
* 무의식속에서 DB 캐시를 의존하며 코딩하곤 했었습니다. 
* 무슨 말인가 하면, "이 쿼리는 자주 발생하게돼. 그렇다면 DB에서 캐시가 적절하게 사용되어 조회 성능에 큰 걱정 없겠지?"
* 와 같이 DB 캐시를 의존하며 쿼리를 작성하고, 이를 이용해 api를 만들었습니다.
* DB의 캐시는 mysql 기준 8.0에서 사라졌고, 
* hibernate가 2차캐시 상에서 엔티티를 캐싱할 수 있지만, 이는 어디까지 엔티티만 가능하며, dto는 불가능했습니다. 
* 대부분의 쿼리에서 성능 향상을 위해 dto 프로젝션을 사용하는데 이는 2차캐시에 캐싱이 안됩니다.
* 즉 dto projection 한 쿼리자체가 캐싱되는 그런것이 필요했습니다.

## 캐시의 조건
* 캐시는 업데이트가 잦지 않고, 자주 조회되는 데이터에 사용해야합니다.
* 그리고 현재 필자가 일반적으로 사용하고 있는 페이징 방식인 no-offset 기반의 페이징을 비롯한 **페이징에서는 사용해선 안됩니다**.
* 캐시의 키를 설정하기 까다롭기 때문입니다. 단건의 경우 캐시 키를 설정하기 쉽습니다. 다양한 방식으로 설정가능합니다.
* 일례로 `url + id`로 설정하거나, `도메인이름 + id`로 설정하면 됩니다.
* 페이징은 그렇지 않습니다. 페이지마다 metadata들이 다르고, 
* 하나의 페이지에 페이징 데이터를 제외한 다른 많은 데이터들이 들어가기 때문에(몇 페이지인지, 페이지 사이즈는 몇인지 등) 일일히 모든 페이지를 캐싱하는 것은 올바르지 않습니다.
* 그렇다면 다음과 같은 생각을 할 수 있습니다. 첫번째 페이지는 자주 조회되니깐, 첫번째 페이지만 캐싱해서 사용하면 좋지 않을까?
* 그렇게 사용하기 위해서는 첫번째 페이지가 자주 바뀌지 않아야합니다. 그러나 현실적으로 그렇기는 어렵습니다. 첫 페이지는 자주 바뀌기 때문입니다.
* 결론적으로 페이징 데이터는 자주 바뀝니다. 새로운 데이터가 추가되면 페이징 데이터는 변경되어버립니다.
* 따라서 단건 조회 api에 캐시를 사용하는 것이 제일 적절한 방법입니다.
* 물론 자주 조회되는 도메인에 한하여 말입니다. 혹은 사이즈가 매우 큰 데이터를 가지고 있는 경우이거나요.
* 캐시를 변경할때 `@CachePut` 어노테이션은 메서드의 실행 결과를 캐시에 저장하는데, 이때 캐시에 저장되는 값은 메서드가 반환하는 값입니다. 
* 따라서 command와 query를 분리하는 필자의 정책상 업데이트 메서드에 반환값으로 넣기 안좋으니 해당 캐시데이터를 삭제하는 `@CacheEvict`을 사용하는 것이 좋습니다.
* 즉 캐시는 데이터의 변경이 일어날때 삭제하는 것이 좋습니다. key를 안다면 key에 해당하는 캐시만 삭제하면되겠지요.
* 복합키 데이터는 캐싱을 사용하지 않는것이 좋습니다. 상당히 복잡해집니다.

## 단건 데이터의 캐시
* 단건 데이터의 캐시를 무시해서는 안됩니다.
* hot 한 게시글의 경우 해당 게시글을 call하는 api의 수는 상상을 초월하게 됩니다.
* 이러한 상황 가운데에서 캐시는 빛을 발합니다. DB에 접근하지 않고 바로 캐시에서 값을 긁어오기 때문입니다.
* 해당 데이터가 변경이 일어나서 캐시가 삭제되지 않는이상 hot한 단건 데이터에 대한 조회에서 성능을 끌어올리기 좋기 때문에 단건 데이터의 캐싱을 절대로 무시해서는 안됩니다.

## 주의점
* 간혹 캐시를 쓰다보면 `spel` 에러를 겪을 수 있습니다.(필자가 그랬다...ㅜㅜ)
* 이 에러는 스프링 캐시 추상화의 경우 매개변수를 이용해서 키를 설정하곤 합니다. `@CacheEvic(KEY=어쩌구)`
* 결국에 상수를 쓰더라도 상수의 구현은 문자열입니다. 만약 매개변수와 동일한 네이밍을 쓰지 않거나,
* 매개변수의 네이밍을 바꿧는데 캐시에 사용되는 문자열(상수)의 값을 함께 바꾸지 않았다면 에러가 발생합니다.
* 대표적으로 dto를 매개변수로 할때, dto의 이름을 변경한경우, 캐시에 사용되는 키나 밸류값도 수정해주어야합니다.

## 결론
* 결론은 다음과 같습니다.
* 단건 데이터를 캐싱하면 좋다. 페이징의 경우 캐싱을 하지 말아라. 
* 캐시의 복잡성을 줄이기 위해 key는 하나만 갖는것이 좋다. 그리고 그 키는 외부/내부 식별자를 사용하는 것이 좋다. 즉 최대한 단순하게 캐시를 관리해라.
* 변경이 잦지 않고, 조회가 많이 일어나는 게시글이나 광고, jwt의 refresh token 등에 캐시를 사용하면 아주아주 좋다.
* 캐시의 값을 변경하는 `@CachePut`은 command/query를 분리하는 cqs에 어울리지 않는다. 따라서 데이터의 변경이 일어날 때에는 해당 캐시를 삭제하라.
* 데이터를 삭제하여 캐시 또한 삭제하여야하는 경우, 메서드의 성공/실패 여부를 따지기위해 `beforeInvocation`을 false로 두어 메서드가 끝나고 난 후 캐시가 삭제되도록한다. default는 false이다.