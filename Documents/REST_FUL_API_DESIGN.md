# restful한 api 설계

## 기본 규칙
* rest-api는 재사용을 높이기 위해 아래와 같은 기본적 원칙을 적용한다.
```
생성(post) : /users
컬렉션 조회(get) : /users
상세 조회(get) : /users/{id}
삭제(delete) : /users/{id}
모든 필드 수정(put) : /users/{id}/task
특정 필드 수정(patch) : /users/{id}/task/필드
```

## 명명 규칙
* 파라미터와 json 바디의 필드명은 모두 카멜케이스를 사용한다.
* 파라미터의 이름은 단순히 `id`로 하지 말고, `리소스Id`와 같이 하여 의미를 명확히 한다.
  * ex : `userId`, `orderId`
* uri는 kebab-case를 사용하라. camel-case, snake-case를 사용하지 않는다.
* 리소스(uri 이름)은 복수로 표현한다.
  * ex : `users`, `orders`, `posts`
* `by-users`, `by-admin`과 같이 리소스에 uri를 받을 클라이언트를 삽입하는 표현은 좋지 않다.
  * 클라이언트에겐 `summary`, 어드민에겐 `detail`처럼 의미있는 말을 사용하고, uri에 해당 uri를 받을 클라이언트 이름을 삽입하지 않는다.

## 행위 부여
* 이해를 돕기위해 행위를 명시적으로 부여하는 것은 가능하다.
* 반드시 uri는 `/리소스/{리소스Id}/행위/행위를 당하는 필드`의 템플릿을 따른다.
* 만약 행위를 당하는 필드가 없고, 모든 필드가 행위를 당한다면, 즉 http method가 put이라면 행위를 당하는 필드를 명시하지 않는다.
* 아래의 예시는 올바른 예시이다.
```
[모든 필드에 대해 행위를 부여할 때]
/post/{id}/edit

[단건 필드에 대해 행위를 부여할 때]
/post/{id}/edit/title
```
* `/리소스-행위/{리소스Id}`의 템플릿은 좋지 않다.
* 아래의 예시는 바르지 않은 예시이다.
```
/post-edit/{id}
```

## DB 테이블에 종속되지 않는 api
* 도메인이 그렇듯 api 또한 DB 테이블에 1대1로 대응되는, 종속되는 api를 만들지 않는다.
* 주문의 경우 반드시 orders 테이블이 존재할 필요가 없으며, 여러 테이블이 모여서 주문을 진행할 수 있다.
* 또 다른 예시로 특정 회원의 주문을 조회할 때 `member/1/orders`와 같이 설계하는 것이 좋다.
* 다만 이때 필요한 DB 테이블이 주문이기에 무조건 orders 도메인에서 관리하려하면 피곤해진다.
* `orders service`에서는 조회할 수 있는 메서드를 제공하되, 이를 `member`에서 관리하는 것이 맞다.
* api는 테이블과 1:1 매칭 대상이 아니라는 것을 유념해야한다.
* 만약 조회가 아닌 command 작업이라면 파사드 패턴을 사용해서 처리할 수도 있다.
* 위와 같은 형태의 api로 만들려면, 다른 도메인의 service를 반드시 참조해야하는데, 이때 여러 고민이 들 수 있다.
* 이 때에는 파사드 패턴(통합 서비스)을 활용해서 처리하면 트랜잭션과 여러 서비스가 물리는 상황에서도 유연하게 대처할 수 있다.
* 다른 도메인의 service를 많이 참조해야하는 상황에 대한 자세한 설명은 [링크]()를 참고하면 좋다.

## path variable은 가능한 하나만 사용하라
* path variable은 가능한 한 개만 사용하는 것이 좋다.
* 마치 `/members/{memberId}/orders/{orderId}`와 같은 형식의 api는 좋지 않다.
* 왜냐하면 유연성이 떨어지기 때문이다.
* 일례로 중간 계층이 추가된다거나 하는 상황이 발생 할 경우,
* 위와 같은 형태의 api는 모든 구조를 변경해야한다.
* 따라서 api를 간단하게 유지하는 것이 좋다.
* 위와 같은 구조보다는 `/members/{memberId}/orders` api를 두고
* 상세 주문 정보가 필요할 경우 `/orders/{orderId}`api를 사용해서 상세 주문정보를 가져오는 것이 올바르다.
* 만약 orders 정보를 가져올 때, 회원 id(memberId)가 필요하다면 이는 orders 도메인의 id가 유니크 하지 않음을 의미한다.
* 이렇게 유니크 하지 않은 id를 사용하여 정보를 조회하는 것은 아주 나쁘므로 도메인의 id는 유니크하게 유지하고 이를 사용하여 가벼운 형태의 api를 만드는 것이 좋다.

## 회원의 보안 관련 api 규칙
* 회원과 관련된 api에는 path에 id를 삽입하지 않는다. 이는 보안을 높이기 위함이다.
* jwt 토큰을 통해 회원의 식별자를 내부적으로 파악하는 방식을 사용하고, 외부에 식별자를 노출시키지 않는다.
* 정말 필요하다면, 노출 가능한 식별자인 외부 식별자를 사용하여 표현한다. 이에 대해 자세한 설명은 [다음 링크](./INTERNAL_EXTERNAL_PK.md)를 참고하라.

## 업데이트 시 어떤 http method를 사용해야하나? : PUT? PATCH?
* 수정시에는 put 메서드를 사용하여 전체 컬럼을 받아 업데이트 하는 것을 권고한다.
* 그러나 이는 데이터 필드 수가 적을때 이야기이며, 개발자가 판단할 때 필드가 많다면 patch를 통해 필요한 부분만 업데이트 하는 것을 권장한다.
* 이유는 필드가 많을 경우 오버헤드가 발생할 수 있기 때문이다.
* jpa의 더티체킹을 이용하는 경우일지라도 client로 부터 전체 필드를 받아 업데이트 하는 것이 아니라면 patch로 처리한다.
