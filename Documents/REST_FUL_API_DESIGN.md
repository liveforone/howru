# restful한 api 설계

## 기본 규칙
* rest-api는 재사용을 높이기 위해 아래와 같은 기본적 원칙을 적용한다.
```
생성(post) : /users
컬렉션 조회(get) : /users
상세 조회(get) : /users/{id}
삭제(delete) : /users/{id}
모든 필드 수정(put) : /users/{id}/task
특정 필드 수정(patch) : /users/{id}/task/필드
```

## 명명 규칙
* 파라미터와 json 바디의 필드명은 모두 카멜케이스를 사용한다.
* 파라미터의 이름은 단순히 `id`로 하지 말고, `리소스Id`와 같이 하여 의미를 명확히 한다.
  * ex : `userId`, `orderId`
* uri는 kebab-case를 사용하라. camel-case, snake-case를 사용하지 않는다.
* 리소스(uri 이름)은 복수로 표현한다.
  * ex : `users`, `orders`, `posts`
* `by-users`, `by-admin`과 같이 리소스에 uri를 받을 클라이언트를 삽입하는 표현은 좋지 않다.
  * 클라이언트에겐 `summary`, 어드민에겐 `detail`처럼 의미있는 말을 사용하고, uri에 해당 uri를 받을 클라이언트 이름을 삽입하지 않는다.

## 행위 부여
* 이해를 돕기위해 행위를 명시적으로 부여하는 것은 가능하다.
* 반드시 uri는 `/리소스/{리소스Id}/행위/행위를 당하는 필드`의 템플릿을 따른다.
* 만약 행위를 당하는 필드가 없고, 모든 필드가 행위를 당한다면, 즉 http method가 put이라면 행위를 당하는 필드를 명시하지 않는다.
* 아래의 예시는 올바른 예시이다.
```
[모든 필드에 대해 행위를 부여할 때]
/post/{id}/edit

[단건 필드에 대해 행위를 부여할 때]
/post/{id}/edit/title
```
* `/리소스-행위/{리소스Id}`의 템플릿은 좋지 않다.
* 아래의 예시는 바르지 않은 예시이다.
```
/post-edit/{id}
```

## api의 주인
* api의 경우 리소스에 관계없이 주인이 있는 경우가 있다.
* 일례로 '작성자의 게시글'과 같은 것이 그러하다.
* 이 경우에는 아래와 같은 규칙을 따른다.
* api의 주인이 조회자와 동일할 경우 세션에 저장된 회원정보나, jwt 토큰에 저장된 회원 정보를 사용해서 처리한다.
* 즉 이 때에는 파라미터로 조회자 정보를 가져오진 않는다.
* 그러나 조회자와 api의 주인이 다를경우에는 `/리소스/{api주인}/행위`와 같이 표현한다.
```
[api의 주인이 조회자와 동일할 경우]
/posts/my

[api의 주인이 조회자와 동일하지 않을 경우]
/posts/member/{memberId} : 작성자의 게시글 조회(작성자(api 주인) != 조회자)
```

## 회원의 보안 관련 api 규칙
* 회원과 관련된 api에는 path에 id를 삽입하지 않는다. 이는 보안을 높이기 위함이다.
* jwt 토큰을 통해 회원의 식별자를 내부적으로 파악하는 방식을 사용하고, 외부에 식별자를 노출시키지 않는다.
* 정말 필요하다면, 노출 가능한 식별자인 외부 식별자를 사용하여 표현한다. 이에 대해 자세한 설명은 [다음 링크](./INTERNAL_EXTERNAL_PK.md)를 참고하라.

## 업데이트 시 어떤 http method를 사용해야하나? : PUT? PATCH?
* 수정시에는 put 메서드를 사용하여 전체 컬럼을 받아 업데이트 하는 것을 권고한다.
* 그러나 이는 데이터 필드 수가 적을때 이야기이며, 개발자가 판단할 때 필드가 많다면 patch를 통해 필요한 부분만 업데이트 하는 것을 권장한다.
* 이유는 필드가 많을 경우 오버헤드가 발생할 수 있기 때문이다.
* jpa의 더티체킹을 이용하는 경우일지라도 client로 부터 전체 필드를 받아 업데이트 하는 것이 아니라면 patch로 처리한다.
