# refresh token을 이용한 jwt 토큰 재발급 매커니즘

## 개요
* 상황과 환경에 따라 재발급 매커니즘은 바뀔 수 있다.
* 통상적으로 사용되는 방식이 아닌 필자는 필자만의 방식으로 처리했다.
* 이 방식 종종 사용되는 편으로 메이저한 방식은 아니다.
* 들어가기 전 글을 이해하려면 jwt 토큰에 대해 잘 알고 있어야한다.
* 또한 필자는 프로젝트에서 회원의 외부 식별자로 db의 id를 쓰는 것이 아닌 따로 만들어 저장하고 있는 uuid를 사용한다.

## 엔티티
* jwt의 모든 토큰을 담을 필요가 없다.
* access 토큰이 만료되면 refresh 토큰을 이용해 jwt 토큰을 재발급 받는 것이기 때문에 refresh 토큰만 저장하면된다.
* 다만 회원의 식별할 수 없으니 적절한 회원의 식별자(필자는 uuid를 사용함)를 같이 넣어 저장하면된다.
* 저장되는 refresh token은 nullable해야한다(향 후 변경이 가능하므로).

## refresh 토큰의 라이프 사이클
* 토큰은 로그인시 생성된다.
* 토큰은 로그아웃시 null로 변경한다.
* 회원 탈퇴시 토큰 데이터는 삭제된다.

## 로그인 후 동작방식
* 로그인을 하게되면 access token과 refresh 토큰을 발급하여 client에게 보낸다.
* client는 적절한 장소에 저장하여 아래와 같이 사용한다.
* 일반적으로 대부분의 요청(회원가입/로그인 등을 제외한)에는 access 토큰을 헤더에 넣어 서버에 보낸다.
* 그리고 필터는 이 토큰이 유효한지 판단한다.
* 이때 토큰이 만료된경우 필터에서는 토큰이 만료되었다는 response를 client로 보낸다.
* 여기서 필요한 것은 토큰의 재발급 요청을 처리할 api이다. 
* 해당 api로 client는 헤더에 refresh token과 회원의 식별자(uuid)를 넣어서 토큰의 재발급을 요청한다.
* 이 api는 시큐리티가 막지 않도록 permit all로 설정함에 유의한다.
* 헤더의 uuid(회원의 식별자)로 db에 저장된 refresh token을 찾는다.
* 찾은 refresh token과 헤더의 refresh token을 비교하고, 유효성 검사(만료/일치한지/empty 등)를 진행한다.
* 유효성이 적절하다 판단되면 access token과 refresh 토큰을 새로 발급하여 client에게 전달하고, db의 refresh 토큰의 값을 변경한다.
* client는 다시 새 access 토큰을 헤더에 삽입하여 기존의 url로 재요청한다.

## 로그아웃 동작방식
* 로그아웃을 하게되면 db에 저장된 refresh 토큰을 null로 변경한다.

## 회원 탈퇴 동작방식
* 연관관계는 맺지 않는다.
* 이유는 토큰 정보는 간단한 정보를 담고 있기 때문에 연관관계를 맺어서 복잡도를 증가시킬 이유가 전혀 없기 때문이다.

## 더 생각해볼것
* no sql이나, redis 같은 캐시처럼 ttl을 스케줄러와 같은 것을 이용해 처리할 수 있다.
* 그러나 이는 더 생각해 볼 것으로 현재의 동작방식에서는 필요가 없다.
