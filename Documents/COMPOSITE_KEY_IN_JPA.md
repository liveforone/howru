# JPA에서 복합키로 조회 쿼리 최적화 및 다량의 in절 쿼리 문제 해결하기

## 복합키 사용 이유
* 해당 프로젝트에서는 팔로우 테이블과 좋아요 테이블에서 복합키를 사용했다.
* 하나의 값이 테이블의 상태를 표현하지 못한다면 당당하게 복합키를 사용하면된다.
* 필자의 경우 팔로워, 혹은 팔로잉을 당하는 주체(followee) 만으로는 팔로우 테이블의 상태를 표현하지 못하겠다고 생각하여
* 복합키로 팔로워(follower)와 팔로잉을 당하는 주체(followee)를 사용하였다.

## JPA에서 복합키 사용
* JPA에서는 두가지 복합키 사용법을 제공한다.
* 하나는 `EmbeddedId`이고 둘째는 `IdClass`이다.
* 필자는 `IdClass`를 사용하였다. 이 방법이 `EmbeddedId`보다 편리하고 관리하기 쉬워보여서 사용했다.
* 특히 필자의 경우 조회시에 복합키 자체로 조회 하는 것 뿐만아니라 하나의 컬럼만으로도(= 복합키중 하나의 컬럼 만으로도) 조회하는 쿼리가 많아서 이렇게 결정하였다.

## 코틀린 복합키 사용 유의점
* 코틀린에서는 복합키를 사용할 때 딱 한가지 유의점이 있는것 같다.
* 복합키 클래스에서 기본 생성자가 필요한데,
* 이렇게 기본생성자를 정의하지 말고, 아래처럼 값을 미리 할당하는 것이다.
* 이렇게 미리 할당해야 에러가 발생하지 않고 정상적으로 처리되며, 기본생성자 사용방식보다 훨씬 간편하다.
```kotlin
data class SubscribePk(
    val followeeUUID: UUID? = null,
    val followerUUID: UUID? = null
) : Serializable
```

## 복합키의 주의점1 : 순서
* 복합키 자체의 주의점도 있다.
* 바로 키의 순서이다. 특히나 인덱스가 정상적으로 작동하도록 순서를 주의해서 설정해야한다.
* 순서는 DB에 들어가서 확인하면 나오고, 필자의 경우 followeeUUID -> followerUUID 순으로 되어있었다.
* 따라서 반드시 조회시에 이 순서대로 집어넣어야 기본키 인덱스가 걸린다.

## 복합키의 주의점2 : 정렬 어려움
* 복합키의 두번째 주의점은 정렬이 어렵다는 것이다.
* 따라서 정렬가능한 컬럼을 삽입하면 아주 큰 도움이된다.
* 어떤것이 가볍고, 정확하게 정렬가능하며, 값을 쉽게 삽입할 수 있을까 고민하던 중 금융권의 사례를 알게되었다.
* 금융권의 경우 날짜를 숫자로(`datetime`이 아닌) 집어넣는다는것이다.
* 예를 들면 2024년 1월 8일은 20240108 과 같은 형태로 삽입하는 것이다.
* `datetime` 타입의 경우 `int` 형보다 성능이 현저히 떨어지므로 이렇게 사용하는것이다.
* 따라서 필자도 날짜를 삽입하기로 마음먹었고, 또한 `int`형으로 삽입하도록 설계하였다.
* 여러 날짜 생성방법 중 `unix`의 `timestamp` 형식을 사용하기로 하였다.
* 앞서 보인 예시의 경우 사람이 눈으로 의미를 확인하기 쉽다.
* 그러나 지금 상황에서는 사람이 눈으로 확인하기 보다는 컴퓨터가 정렬만 할 것이기 때문에 위와 같은 방법을 사용하였다.
* 이 `unix timestamp`의 경우 시간이 지날수록 숫자가 커진다.
* `auto_increment`와 비슷하다고 생각하면된다.
* 사용법도 똑같이 `desc, asc`하여 사용하면된다.
* 이 방법은 `auto_increment`처럼 종속되지도 않고, 캐쉬를 이용해 기억할 필요없이 그냥 아래 함수를 이용해 값을 뽑아내면된다.
```kotlin
fun getCurrentTimestamp(): Int {
    return Instant.now().epochSecond.toInt()
}
```

## 조회쿼리가 이상하다 - 다량의 in 절 쿼리 문제가 발생
* 복합키를 이용해 조회하게되면 조금 이상한 점을 발견할 수 있다.
* jpa에서 기본으로 지원하는 `findBy`와 같은 메서드를 잘 사용하지 않는데, 동작방식이 궁금해서 사용을 해보았다.
* 해당 메서드를 사용하려면 복합키를 넣어서 사용하게된다.
* 쿼리 로그는 아래처럼 찍혀나온다.
```sql
where (
s1_0.followee_uuid,s1_0.follower_uuid
) in ((?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?),(?,?))
```
* 굉장히 기괴한 쿼리가 나간다. `in`절을 사용하지도 않았는데, 자동으로 굉장히 긴 `in`절이 나간다.
* 이러한 문제의 이유가 무엇이냐면 복합키는 최소 두개의 키로 이루어져 있는데,
* 복합키 중 하나의 키만을 가지고 조회를 할 수도 있다.
* 이때 jpa는 하나의 키로 가능한 복합키 조합을 찾기위해 여러 `in`쿼리를 사용하게 된다.
* 즉 jpa에서 제공하는 메서드를 사용할 때, 하나의 키만으로 데이터를 조회하는 쿼리를 날리는 것은 성능에 좋은 영향을 주지 못한다.
* 이 때에는 `jdsl`이나 `QueryDsl`, `Jpql`등을 사용해서 커스텀 쿼리를 날리면 이러한 문제가 해결된다.
* 아래는 `jdsl`과 `QueryDsl`로 작성된 코드이다. 복합키 순서는 followeeUUID -> followerUUID를 지켜서 작성하였다.
```kotlin
//jdsl
override fun findSubscribeById(followeeUUID: UUID, followerUUID: UUID): Subscribe {
        return try {
            queryFactory.singleQuery {
                select(entity(Subscribe::class))
                from(Subscribe::class)
                where(col(Subscribe::followeeUUID).equal(followeeUUID).and(col(Subscribe::followerUUID).equal(followerUUID)))
            }
        } catch (e: NoResultException) {
            throw SubscribeException(SubscribeExceptionMessage.SUBSCRIBE_IS_NULL)
        }
}

//QueryDsl
override fun findSubscribeById(followeeId: UUID, followerId: UUID): Subscribe {
    return jpaQueryFactory.selectFrom(subscribe)
        .where(subscribe.followeeId.eq(followeeId).and(subscribe.followerId.eq(followerId)))
        .fetchOne() ?: throw SubscribeException(SubscribeExceptionMessage.SUBSCRIBE_IS_NULL, followerId)
}
```
* 한 개의 키만을 이용해서 복합키 테이블을 조회할 때에는 jpa의 기본 메서드를 사용하지 말아라.
