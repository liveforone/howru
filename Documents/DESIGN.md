# 전체 설계

## 엔티티
### setter
* 자바의 보일러 코드를 없앨 목적으로 만들어진 코틀린인 만큼, 코틀린의 기능을 100% 활용해야 한다고 생각한다.
* 이에 따라 `setter`를 막는 다양한 방법들을 사용하게 되면, 또 보일러 코드가 생성된다.
* 따라서 `setter`는 머릿속에서 지우고, 사용하지 않도록한다.
* 변경은 기존의 자바코드로 했던 방법과 같이 변경 메서드를 만들어서 처리하도록한다.
* 팀으로 개발을 진행할 때에도 보일러 코드를 남기지 않기위해, 팀 컨벤션으로 `setter`를 아예 사용하지 않는 것을 기본으로 한다.
* 영구적/논리적으로 변경이 필요하지 않을 값에 한해 `val`(불변)으로 선언하여 `setter`를 막는다.
* trade off의 영역이다. 컨벤션으로 맞추자.
### 타입은 기본적으로 불변으로 한다.
* 논리적으로 변경이 필요한 값이 아니라면 `val`로 선언하여, 불변으로 선언한다.
* `val`는 `setter`를 만들지 않고, `getter`만 만들기에 처음 설명한 `setter`문제를 고민할 필요도 없으며, 사이드 이펙트를 발생시키지 않는다.
### 외부 식별자
* `uuid` 형식의 외부 식별자를 두어, `primary key`가 외부로 노출되지 않도록 한다.
* `primary key`는 오로지 조인과 내부적인 동작을 위해서만 사용한다.
* 외부 식별자 타입은 `binary 16`으로 설정한다.
* 모든 데이터에 한해 외부 식별자를 사용하라는 것은 아니지만, 보안이 중요한 테이블과 회원 테이블은 반드시 외부 식별자를 사용한다.
### @Enumerated 대신에 Converter를 사용
* 스프링 부트 3.0.0 버전에서 `@Enumerated` 어노테이션이 작동하지 않는 문제가 발생했었다.
* 이러한 문제로 해당 어노테이션을 불신하게 되었고, 코드로 동작하는 `converter`를 이용해서 타입을 변경하도록 한다.
* 이 방법은 향후에 벌어지게될 비슷한 이슈를 사전에 차단할 수 있다.
### 적정 타입/크기 사용
* 테이블의 필드들은 적절한 타입과 크기를 사용한다.
* 불필요한 사이즈와 불필요한 타입을 사용하여, 자원을 낭비하지 않는다.
* 따라서 미리 타입과 크기를 선언하고, 테이블 생성시 뿐만 아니라 엔티티에도 `columnDefinition`을 통해서 타입과 크기를 지정하라.
### 단방향 연관관계 사용
* 양방향은 관리가 상당히 까다롭다. 단방향 연관관계로 대부분의 상황에서 충분히 문제없이 개발이 가능하다.
* 따라서 단방향 연관관계를 기본적으로 사용하되, 필요시 양방향을 설정한다.
* 절대로 양방향 연관관계를 남발하지 않는다.
### on delete cascade는 조심히 다룬다.
* `on delete cascade`는 hibernate log를 남기지 않고 삭제시켜버린다.
* 논리적으로 합당한 경우에만 `on delete cascade`를 사용하도록 한다.

## DTO
### response dto는 불변으로 선언한다.
* 값의 가공이 필요없고, 가공이 이미 완료된 상태로써, 클라이언트에게 전달하는 response dto는 불번(`val`)으로 선언한다.

## repository
### dto projection 사용
* 대부분의 상황에서 엔티티를 직접 조회할 필요는 없다.
* 엔티티의 모든 값이 필요한 경우는 거의 없다. `jpa`의 더티체킹을 이용하는 경우가 아니라면 말이다.
* 즉 더티체킹처럼 `command`작업이 아닌 이상 엔티티의 모든 필드를 조회할 합당한 이유는 거의 없다.
* 따라서 필요한 데이터만을 조회한다. 이는 정적쿼리, 동적쿼리 모두 해당한다.
* 필요한 데이터만을 조회하는 `dto projection`을 통해서 쿼리의 성능을 충분히 향상시킬 수 있다.
* 이는 불필요한 오버헤드를 줄여준다.
### 조인
* 원하는 필드만 조회하거나, 연관관계가 조건절에만 사용되는 경우에는 `fetch join`을 피하고, `join`을 사용하라.
* 불필요하게 모든 데이터를 다 가져오는 `fetch join을` 할 필요가 없다.
* `fetch join`이 꼭 필요한 상황에서만 `fetch join`을 사용하라.
* 또한 `join`이 필요없는 fk를 사용하는 경우에는 무의식적으로 `join`을 사용하지 말아라.
### no-offset 페이징을 사용한다.
* 페이징은 일반적인 페이징에 비해 복잡하지만, 성능을 끌어올릴 수 있는 `no-offset` 페이징을 사용한다.
* `limit-size`에 대해서는 필요한 만큼 상수를 만들어 사용한다.
### 복합키
* 복합키는 `idClass`를 사용한다.
* 복합키는 순서가 매우 중요하다. 특히나 인덱스를 잘 타게 하기 위해서는 순서를 잘 지켜서 조회해야한다.
* 순서가 곧 성능으로 이루어지기 때문에, 순서만 주의한다면 성능상 문제는 거의 없다.

## controller
### response 객체를 따로 만든다.
* command 작업 후 리턴하는 객체는 status와 body가 까다롭고 복잡한 경우가 많다.
* 이를 controller 단에서 setting을 한다면 코드가 깔끔하지 않게 느껴진다.
* 따라서 커맨드 작업의 복잡한 response를 추상화 한 객체를 만들어 처리하여, 이러한 문제를 해결하라.
### Command의 경우 log를 반드시 찍는다.
* Command 작업의 경우, 즉 `Post, Put, Patch, Delete http-method`로 들어온 request의 경우 반드시 log를 찍어 남긴다.
* log는 간결하게 담는다. log가 오버헤드를 가져오는 경우도 적지만 있다.
* 최상위 계층에서 선언한 `logger`객체를 사용하도록한다.
### 화면에 종속적이지 않은 api를 만들어라
* 화면에 종속적인 api는 불필요하게 데이터를 병합하고, 데이터를 순수한 상태가 아닌 복잡하게 다루게 되는 경향이 있다.
* 그리고 그러한 api는 재사용도 사실상 힘들다.
* 요즘은 `msa`같은 아키텍처들이 곽강받고 있다.
* 이러한 환경에서는 더욱이 화면에 종속적인 api가 어울리지 않는다.
* 하나의 화면에 여러 api를 사용해서 data를 가져오고 사용하는 것이 더욱 지혜로운 방법이다.
* 따라서 `rest-api`를 설계할때, 화면을 기점으로 design하기 보다,
* 기능(혹은 리소스)을 중점으로 design하는 것이 화면에 종속적이지 않고, 재사용성이 뛰어나며, 성능 좋은 api를 만들 수 있는 밑거름이 된다.

## 테스트
### 테스트는 검증이 필요한 경우라면 모두 진행한다
* 서비스 로직을 예로 하면, command 서비스에 대해서만 테스트를 진행하고, query의 경우 테스트를 진행하지 않는 경우가 있다.
* 이래서는 안된다. query 메서드의 경우도 조건이 복잡하고, 검증해야할 상황이 오히려 command보다 많다.
* 따라서 복잡한 쿼리 메서드(복잡한 페이징, 조인, 랜덤, 추천)의 경우 반드시 테스트를 진행하라.

## 함수
### 유틸성 함수는 최상위 함수로 선언
* 유틸성 함수들은 최상위 함수로 선언하여 좀더 간결하게 표현한다.
### 인자수가 많을 시 인자 명시
* 함수에 인자수가 3개 이상이면 인자를 명시한다.
* 함수의 인자는 적을 수록 좋으나, 정적 팩토리 메서드와 같이 객체를 생성하는 경우, 많은 인자가 필요할 수 밖에 없다.
* 이 경우 코틀린에서 지원하는 인자 명시 기능을 사용한다.
### 가능한 단일 표현식 사용
* 가능하다면 함수는 단일 표현식을 사용하되, 불가능한 경우 일반적인 함수 표현식을 사용한다.
* 간단한 쿼리 메서드(단건 조회)의 경우 특히나 단일 표현식을 사용하라.
### 함수의 크기를 줄일때, 종속적 코드의 경우 로컬 함수로 대체한다.
* 함수의 크기를 줄이거나, 함수의 의존성을 분리해낼때,
* 코드가 종속적이여서 재활용이 불가능한 경우에는 `private`한 외부 함수보다는, 로컬함수를 사용하는 것이 좋다.
### 함수는 하나의 책임만 진다.
* 함수의 책임에 대해서는 말이 많다. 필자가 이야기하는 책임은 여러 책에서 설명하는 책임보다 클 수 있다.
* 하나의 일을 하는 함수를 만드는 것은 복잡한 비즈니스로직이 주를 이루는 프로젝트에서 사실상 불가하다.
* 따라서 로그인이면 로그인, 게시글 등록이면 게시글 등록과 같은, 어떤 이벤트에 대해 책임 지도록 하는 것이 옳다.

## 상수
### 매직넘버, 매직 리터럴의 사용은 금한다
* 매직넘버와 매직 리터럴은 사용하지 않는다. 상수를 이용해 대체한다.
* 이를 통해 유지보수의 용이성과 깔끔한 코드 스타일을 가져갈 수 있다.
* url을 비롯해, 정적쿼리, 파라미터, 도메인 상수, 엔티티 필드 타입 등 모든 리터럴과 넘버는 상수를 사용한다.
### 어노테이션 상수는 enum을 사용하지 않는다.
* 어노테이션 안에 들어갈 값을 상수로 만들경우, enum을 사용이 불가하다.
* 어노테이션은 오로지 `String`타입으로 선언한 매개변수로 받는다. 따라서 enum을 사용하지 말아라.

## 보안
### spring security
* 기본적인 보안은 스프링 시큐리티를 사용한다.
* url에 관한 permit 설정과 `auth`체킹을 진행한다.
### Jwt token
* `jwt`는 전체적인 권한에 대해 다룬다.
* 대부분의 경우 사용자를 jwt 토큰을 이용해 체킹한다.
* 로그인 시 `access-token`, `refresh-token`, `uuid`를 클라이언트에게 리턴한다.
* 서버의 입장에서 `jwt`는 상당히 신뢰할만 하고, stateless한 상태를 유지할 수 있다는 메리트가 있기 때문에 사용한다.

## 예외처리
### 모든 예외는 controller advice로 클라이언트에게 완벽히 전달한다.
* 불친절한 예외는 에러를 찾아내기 어렵다. 따라서 `controller advice`를 활용해, 클라이언트에게 정확하게 에러를 전달한다.
### 커스텀 예외
* 모든 도메인에 대하여 커스텀 예외를 만든다.
* 커스텀 예외는 message객체와 exception 객체로 나뉜다.
* message 객체는 리턴 status와 리턴 메세지를 담고 있으며, exception 객체는 message를 매개변수로 받아 controller advice에게 전달한다.
### 예외는 추적가능하도록 한다
* 이것에 관한 것은 별도의 문서로 작성하였다. 아래 문서를 참고바란다.
* [추적가능한 예외처리](https://github.com/liveforone/howru/blob/master/Documents/TRACEABLE_EXCEPTION.md)

## Others
* 위에서는 간략하게 주요한 부분의 설계와 요구에 대해 설명하였다.
* 더 디테일한 사항에 대해서는 각 문서를 참고하길 바란다.
