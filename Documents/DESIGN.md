# 전체 설계

## 엔티티
### setter
* 자바의 보일러 코드를 없앨 목적으로 만들어진 코틀린인만큼, 코틀린의 기능을 100% 활용해야한다고 생각한다.
* 이에 따라 setter를 막는 다양한 방법들을 사용하게되면, 또 보일러 코드가 생성된다.
* 따라서 setter는 머릿속에서 지우고, 사용하지 않도록한다. 아니 setter는 아예 모르는 거다.
* 변경은 기존의 자바코드로 했던 방법과 같이 변경 메서드를 만들어서 처리하도록한다.
* 팀으로 개발을 진행할 때에도 보일러코드를 남기지 않기위해, 팀 컨벤션으로 setter를 아예 사용하지 않는것을 기본으로 한다.
* trade off의 영역이다. 컨벤션으로 맞추자.
### 외부 식별자
* uuid 형식의 외부 식별자를 두어, primary key가 외부로 노출되지 않도록 한다.
* primary key는 오로지 조인과 내부적인 동작을 위해서만 사용한다.
* no-offset 페이징시에 primary key 조회 쿼리가 더 날라가지만 보안성을 위해서 외부식별자를 반드시 사용한다.
* 외부 식별자 타입은 바이너리 16으로 설정한다.
### @Enumerated 대신에 Converter를 사용
* 스프링 부트 3.0.0 버전에서 @Enumerated 어노테이션이 작동하지 않는 문제가 발생했다.
* 이러한 문제로 해당 어노테이션을 불신하게 되었고, 코드로 동작하는 converter를 이용해서 타입을 변경하도록 한다.
### 적정 타입/크기 사용
* 테이블의 필드들은 적절한 타입과 크기를 사용한다.
* 불필요한 사이즈와 불필요한 타입을 사용하여, 자원을 낭비하지 않는다.
### 단방향 연관관계 사용
* 양방향은 관리가 상당히 까다롭다. 단방향 연관관계로 대부분의 상황은 충분하다.
* 따라서 단방향 연관관계를 기본적으로 사용하되, 필요시 양방향을 설정한다. 절대로 양방향 연관관계를 남발하지 않는다.
### on delete cascade는 조심히 다룬다.
* on delete cascade는 hibernate log를 남기지 않고 삭제시켜버린다.
* 논리적으로 합당한 경우에만 on delete cascade를 사용하도록 한다.
### 타입은 기본적으로 불변으로 한다.
* 논리적으로 변경이 필요한 값이 아니라면 val로 선언하여, 불변하도록 한다.
* val는 setter를 만들지 않고, getter만 만들기에 처음 설명한 setter문제를 고민할 필요도 없으며,
* 사이드 이펙트를 발생시키지 않는다.

## DTO
### dto는 val로 선언하고, nullable하게 한다.
* dto의 값을 validation하는 것이 기본적인 dto setting이다.
* 이 경우 val로 선언하고 ?를 사용하여 nullable하게 받아야 적절한 validation이 가능해진다.
### DTO는 필요에 따라 생성한다.
* dto projection마다 필요한 dto, request유형에 따라 필요한 dto 등, 필요에 따른, 필요에 종속적인 dto를 생성하여 사용한다.
* 일례로 회원가입과 로그인 이라면, SignupRequestDto, LoginRequestDto 처럼 각 필요와 이벤트에 맞추어 dto를 생성하는 것이 좋다.
* 이는 앞서 말했듯 dto projection에서도 마찬가지 이다. 각 쿼리별로 필요한 dto를 만드는 것이 좋다.

## repository
### dto projection 사용
* 대부분의 상황에서 엔티티를 직접 조회할 필요는 없다.
* 엔티티의 모든 값이 필요한 경우는 거의 없다. jpa의 더티체킹을 이용하는 경우가 아니라면 말이다.
* 따라서 필요한 데이터만을 조회한다. 이는 정적쿼리, 동적쿼리 모두 해당한다.
* 필요한 데이터만을 조회하는 dto projection을 통해서 쿼리의 성능을 충분히 향상시킬 수 있다.
### 조인
* 원하는 필드만 조회하거나, 연관관계가 조건절에만 사용되는 경우에는
* fetch join을 피하고, join을 사용하라. 
* 불필요하게 모든 데이터를 다 가져오는 fetch join을 할 필요가 없다.
* fetch join이 꼭 필요한 상황에서만 fetch join을 사용하라.
### no-offset 페이징을 사용한다.
* 페이징은 일반적인 페이징에 비해 복잡하지만, 성능을 끌어올릴 수 있는 no-offset 페이징을 사용한다.
* limit-size에 대해서는 필요한 만큼 상수를 만들어 사용한다.
### 복합키
* 복합키는 idClass를 사용한다.
* 복합키는 순서가 매우 중요하다. 특히나 인덱스를 위해서 순서를 잘 지켜서 조회해야한다.
* 순서가 곧 성능으로 이루어지기 때문에, 순서만 주의한다면 성능상 문제는 거의 없다.

## controller
### response 객체를 따로 만든다.
* response의 경우 rest-api를 사용한다면 ResponseEntity 같은 객체를 이용해 status와 body 옵션 등을 줄것이다.
* 그러나 이러한 코드는 보기도 좋지 않고, 관리하기 까다롭다.
* 따라서 response 객체를 만들어서 처리한다. response 객체안에는 return할 response를 담은 함수,
* 즉 ResponseEntity의 wrapper와 클라이언트에게 전달할 메세지 상수등을 담는다.
### validation은 binding에 대해서만 진행한다.
* validation은 binding에 한하여서만 진행한다. 깊은 수준의 검증은 service나 다른 계층으로 넘긴다.
* validateBinding을 하는 최상위 함수를 만들어서, binding result를 검증한다.
### Command의 경우 log를 반드시 찍는다.
* Command 작업의 경우, 즉 Post, Put, Patch, Delete http-method로 들어온 request의 경우 반드시 log를 찍어 남긴다.
* log는 간결하게 담는다. 최상위 계층에서 선언한 logger객체를 사용하도록한다.
### 화면에 종속적이지 않은 api를 만들어라
* 화면에 종속적인 api는 불필요하게 데이터를 병합하고, 데이터를 순수한 상태가 아닌 복잡하게 다루게 되는 경향이 있다.
* 그리고 그러한 api는 재사용도 사실상 힘들다. 
* 요즘은 msa같은 아키텍처들이 곽강받고 있다. 
* 이러한 환경에서는 더욱이 화면에 종속적인 api가 어울리지 않는다.
* 하나의 화면에 여러 api를 사용해서 data를 가져오고 사용하는 것이 더욱 지혜로운 방법이다.
* 따라서 rest-api를 설계할때, 화면을 기점으로 design하기 보다, 
* 기능을 중점으로 design하는 것이 화면에 종속적이지 않고, 재사용성이 뛰어나며, 성능 좋은 api를 만들 수 있는 밑거름이 된다. 

## 테스트
### 테스트는 검증이 필요한 경우라면 모두 진행한다
* 서비스 로직을 예로 하면, command 서비스에 대해서만 테스트를 진행하고, query의 경우 테스트를 진행하지 않는 경우가 있다.
* 이래서는 안된다. query 메서드의 경우에도 조건이 복잡하고, 검증해야할 상황이 오히려 command보다 많다.
* 따라서 하나의 메서드에 대해 다양한 상황을 두고 테스트하는 것이 옳다. 
* 또한 create, update, delete 작업에 대해서만 테스트를 진행하는 것이 아니라 read 작업에 대해서도 테스트를 반드시 진행하라.

## 함수
### 유틸성 함수는 최상위 함수로 선언
* 유틸성 함수들은 최상위 함수로 선언하여 좀더 간결하게 표현한다. 유틸성 함수는 최상위 함수로 선언
* 유틸성 함수들은 최상위 함수로 선언하여 좀더 간결하게 표현한다.
### 인자수가 많을 시 인자 명시
* 함수에 인자수가 3개 이상이면 인자를 명시한다.
* 함수의 인자는 적을 수록 좋으나, 정적팩토리같이 객체를 생성하는 경우, 많은 인자가 필요할 수 밖에 없다.
* 이 경우 코틀린에서 지원하는 인자 명시 기능을 사용한다.
### 가능한 단일 표현식 사용
* 가능하다면 함수는 단일 표현식을 사용하되, 불가능한 경우 일반적인 함수 표현식을 사용한다.
### 커맨드와 쿼리 함수로 나누어라
* service 로직 뿐만 아니라 일반적인 함수도 command 함수와 query 함수를 나누어라.
* 이러한 로직은 사이드 이펙트를 줄일 뿐만 아니라, 더욱 강력한 모듈화를 지원해준다.
* command 함수는 리턴값이 반드시 없어야하나, test의 용이를 위해 특정함수(create)의 경우에는 리턴값을 허용한다.
### 함수의 크기를 줄일때, 종속적 코드의 경우 로컬함수로 대체한다.
* 함수의 크기를 줄이거나, 함수의 의존성을 분리해낼때, 
* 코드가 종속적이여서 재활용이 불가능한 경우에는 private한 외부 함수보다는, 로컬함수를 사용하는 것이 좋다.
### 함수는 하나의 책임만 진다.
* 함수의 책임에 대해서는 말이 많다. 필자가 이야기하는 책임은 여러 책에서 설명하는 책임보다 클 수 있다.
* 하나의 일을 하는 함수를 만드는 것은 복잡한 비즈니스로직이 주를 이루는 프로젝트에서 사실상 불가하다.
* 따라서 로그인이면 로그인, 게시글 등록이면 게시글 등록과 같은, 어떤 이벤트에 대해 책임 지도록 하는 것이 옳다.
* 물론 함수를 쪼개고 쪼개서 책임을 분리하고, 최고 함수가 이를 선언하여 사용하는 방법도 마찬가지 이다.
* 이벤트에 대해 단 하나의 책임만 지도록 한다.

## 상수
### 매직넘버, 매직 리터럴의 사용은 금한다
* 매직넘버와 매직 리터럴은 사용하지 않는다.
* 깔끔한 상수를 이용해 대체한다. 이를 통해 유지보수의 용이성과 깔끔함을 모두 가져갈 수 있다.
* url을 비롯해, 정적쿼리, 파라미터, 도메인 상수, 엔티티 필드 타입 등 모든 리터럴과 넘버는 상수를 사용한다.
### 상수는 되도록 enum 사용
* 상수는 되도록 enum을 사용한다.
* 그러나 스프링의 어노테이션안에 들어가는 value는 enum 사용이 불가하므로(string 타입만 사용가능하다. 일반적인 string 상수를 활용해야한다.) 이러한 경우 일반 상수를 사용하도록한다.

## 보안
### spring security
* 기본적인 보안은 스프링 시큐리티를 사용한다.
* url에 관한 permit 설정과 auth체킹을 진행한다.
### Jwt token
* jwt는 전체적인 권한에 대해 다룬다.
* 대부분의 경우 사용자를 jwt 토큰을 이용해 체킹한다.
* 로그인 시 access-token과 사용자의 uuid를 클라이언트에게 리턴한다.
* 서버의 입장에서 jwt는 상당히 신뢰할만 하고, 성능적인 메리트가 있기 때문에 사용한다.

## 예외처리
### 모든 예외는 controller advice로 클라이언트에게 완벽히 전달한다.
* 불친절한 예외는 에러를 찾아내기 어렵다. 따라서 controller advice를 활용해, 클라이언트에게 정확하게 에러를 전달한다.
### 커스텀 예외
* 모든 도메인에 대하여 커스텀 예외를 만든다.
* 커스텀 예외는 message객체와 exception 객체로 나뉜다.
* message 객체는 리턴 status와 리턴 메세지를 담고 있으며, exception은 그런 message를 매개변수로 받아 controller advice에게 전달한다. 
### 모든 예외에 대해서는 패키지로 나누어서 모듈화 한다.
* message는 message 끼리, exception은 exception끼리, advice는 advice끼리 패키지로 묶는다.
* global, common 처럼 공통적으로 예외를 처리하지 않도록한다. 도메인에 따라 모듈화시켜 처리한다.

## Others
* 위에서는 간략하게 주요한 부분의 설계와 요구에 대해 설명하였다.
* 더 디테일한 사항에 대해서는 각 문서를 참고하길 바란다.